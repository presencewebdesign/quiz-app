# API Integration Documentation

## Live Application

üåê **Web App URL**: [https://quiz-app-98108.web.app](https://quiz-app-98108.web.app)

## API Overview

The quiz application integrates with a mock API that provides Error Find quiz data. The API returns structured data containing two different quiz flows with varying question formats. The current implementation successfully fetches data and renders both quiz flows with proper error handling and loading states.

## API Endpoint

```
GET https://s3.eu-west-2.amazonaws.com/interview.mock.data/payload.json
```

## Data Structure

### Root Response

```typescript
interface QuizData {
  name: string; // "Error Find"
  heading: string; // Game description
  activities: Activity[]; // Array of quiz activities
}
```

### Activity Structure

```typescript
interface Activity {
  activity_name: string; // "Activity One" or "Activity Two"
  order: number; // Activity sequence (1, 2)
  questions: Question[]; // Questions array (Flow 1) or Rounds array (Flow 2)
}
```

### Question Structure (Flow 1)

```typescript
interface Flow1Question {
  is_correct: boolean; // Whether the text is correct
  stimulus: string; // Text with errors marked by asterisks
  order: number; // Question sequence
  user_answers: string[]; // User's answers (initially empty)
  feedback: string; // Corrected text with proper formatting
}
```

### Round Structure (Flow 2)

```typescript
interface Round {
  round_title: string; // "Round 1", "Round 2", etc.
  order: number; // Round sequence
  questions: Question[]; // Questions within the round
}
```

## Score Calculation Integration

### QuizEngine Service

The application uses a centralized `QuizEngine` service for consistent score calculation across both quiz flows:

```typescript
// services/quizEngine.ts
export class QuizEngine {
  /**
   * Calculate score based on user answers and questions
   * Handles both Flow1 and Flow2 with unique question identifiers
   */
  static calculateScore(
    userAnswers: Map<string, string>,
    questions: Question[]
  ): ScoreResult {
    let correct = 0;

    questions.forEach((question) => {
      // Use uniqueId if available (for Flow2), otherwise use order (for Flow1)
      const questionKey = question.uniqueId || question.order.toString();
      const userAnswer = userAnswers.get(questionKey);

      // The correct answer is the text from feedback (without asterisks)
      const correctAnswerText = question.feedback.replace(/\*([^*]+)\*/g, "$1");

      if (userAnswer && userAnswer === correctAnswerText) {
        correct++;
      }
    });

    return {
      correct,
      total: questions.length,
      percentage: Math.round((correct / questions.length) * 100),
    };
  }
}
```

### Context Integration

The score calculation is integrated into the `QuizContext` for centralized state management:

```typescript
// contexts/QuizContext.tsx
const calculateScore = (): ScoreResult => {
  let questions;
  let userAnswersForScoring;

  if (flow === "flow1") {
    questions = quizData.activities[0]?.questions || [];
    userAnswersForScoring = state.userAnswers;
  } else {
    // Flow2: Generate unique identifiers and collect all questions
    questions = [];
    quizData.activities[1]?.questions?.forEach(
      (round: any, roundIndex: number) => {
        round.questions.forEach((question: any) => {
          questions.push({
            ...question,
            uniqueId: `${roundIndex}-${question.order}`,
          });
        });
      }
    );
    userAnswersForScoring = state.userAnswers;
  }

  return QuizEngine.calculateScore(userAnswersForScoring, questions);
};
```

### Flow-Specific Handling

**Flow1 (Sequential Questions):**

- Direct key mapping: `userAnswers.get(question.order.toString())`
- Simple key structure: `"1"`, `"2"`, `"3"`

**Flow2 (Rounds-based Questions):**

- Unique identifier generation: `uniqueId: "${roundIndex}-${question.order}"`
- Prevents conflicts when questions across rounds have same order values
- Answer keys: `"0-1"`, `"0-2"`, `"1-1"`, `"1-2"`

### Score Result Interface

```typescript
// types/quiz.ts
export interface ScoreResult {
  correct: number; // Number of correct answers
  total: number; // Total number of questions
  percentage: number; // Percentage score (0-100)
}
```

## TanStack Query Integration

### Query Client Setup

```typescript
// services/queryClient.ts
import { QueryClient } from "@tanstack/react-query";

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      cacheTime: 10 * 60 * 1000, // 10 minutes
      retry: 3, // Retry failed requests
      refetchOnWindowFocus: false, // Don't refetch on window focus
      suspense: true, // Enable Suspense mode
    },
  },
});
```

### API Service Layer

```typescript
// services/quizApiService.ts
import { useQuery } from "@tanstack/react-query";

const QUIZ_QUERY_KEY = "quiz-data";

// Main quiz data query
export const useQuizData = () => {
  return useQuery({
    queryKey: [QUIZ_QUERY_KEY],
    queryFn: async (): Promise<QuizData> => {
      const response = await fetch(
        "https://s3.eu-west-2.amazonaws.com/interview.mock.data/payload.json"
      );

      if (!response.ok) {
        throw new Error(`Failed to fetch quiz data: ${response.status}`);
      }

      const data = await response.json();
      return normalizeQuizData(data);
    },
    suspense: true,
  });
};

// Flow-specific queries
export const useFlow1Data = () => {
  return useQuery({
    queryKey: [QUIZ_QUERY_KEY, "flow1"],
    queryFn: async (): Promise<Flow1Activity> => {
      const data = await fetchQuizData();
      return data.activities[0] as Flow1Activity;
    },
    suspense: true,
  });
};

export const useFlow2Data = () => {
  return useQuery({
    queryKey: [QUIZ_QUERY_KEY, "flow2"],
    queryFn: async (): Promise<Flow2Activity> => {
      const data = await fetchQuizData();
      return data.activities[1] as Flow2Activity;
    },
    suspense: true,
  });
};
```

### Data Normalization

```typescript
// utils/dataNormalization.ts
export const normalizeQuizData = (rawData: any): QuizData => {
  return {
    name: rawData.name || "Error Find Quiz",
    heading: rawData.heading || "Find mistakes in written text",
    activities: rawData.activities?.map(normalizeActivity) || [],
  };
};

const normalizeActivity = (activity: any): Activity => {
  return {
    activity_name: activity.activity_name || "Unknown Activity",
    order: activity.order || 0,
    questions: activity.questions?.map(normalizeQuestion) || [],
  };
};

const normalizeQuestion = (question: any): Question => {
  return {
    is_correct: Boolean(question.is_correct),
    stimulus: question.stimulus || "",
    order: question.order || 0,
    user_answers: question.user_answers || [],
    feedback: question.feedback || "",
  };
};
```

## Error Handling

### API Error Types

```typescript
// types/apiErrors.ts
export interface ApiError {
  message: string;
  status?: number;
  code?: string;
}

export class NetworkError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "NetworkError";
  }
}

export class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "ValidationError";
  }
}
```

### Error Boundary Integration

```typescript
// components/common/ApiErrorBoundary.tsx
import { ErrorBoundary } from "react-error-boundary";

interface ApiErrorFallbackProps {
  error: Error;
  resetErrorBoundary: () => void;
}

const ApiErrorFallback = ({
  error,
  resetErrorBoundary,
}: ApiErrorFallbackProps) => (
  <div className="api-error-fallback">
    <h2>Failed to Load Quiz Data</h2>
    <p>There was an error loading the quiz questions.</p>
    <details>
      <summary>Error Details</summary>
      <pre>{error.message}</pre>
    </details>
    <button onClick={resetErrorBoundary}>Try Again</button>
  </div>
);

export const ApiErrorBoundary = ({
  children,
}: {
  children: React.ReactNode;
}) => (
  <ErrorBoundary
    FallbackComponent={ApiErrorFallback}
    onError={(error) => {
      console.error("API Error:", error);
      // Could send to error reporting service
    }}
  >
    {children}
  </ErrorBoundary>
);
```

## Loading States

### Suspense Integration

```typescript
// App.tsx
import { Suspense } from "react";

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ApiErrorBoundary>
        <Suspense fallback={<LoadingScreen />}>
          <Router>
            <Routes>
              <Route path="/quiz/:flow" element={<QuizPage />} />
            </Routes>
          </Router>
        </Suspense>
      </ApiErrorBoundary>
    </QueryClientProvider>
  );
}
```

### Loading Components

```typescript
// components/common/LoadingScreen.tsx
export const LoadingScreen = () => (
  <div className="loading-screen">
    <div className="spinner" />
    <p>Loading quiz data...</p>
  </div>
);

// components/common/QuizLoadingSkeleton.tsx
export const QuizLoadingSkeleton = () => (
  <div className="quiz-skeleton">
    <div className="skeleton-header">
      <div className="skeleton-title" />
      <div className="skeleton-progress" />
    </div>
    <div className="skeleton-question">
      <div className="skeleton-text" />
      <div className="skeleton-text" />
      <div className="skeleton-input" />
    </div>
  </div>
);
```

## Caching Strategy

### Query Cache Configuration

```typescript
// services/cacheConfig.ts
export const CACHE_KEYS = {
  QUIZ_DATA: "quiz-data",
  FLOW_1: "quiz-data-flow1",
  FLOW_2: "quiz-data-flow2",
  USER_ANSWERS: "user-answers",
} as const;

export const CACHE_TIMES = {
  QUIZ_DATA: 5 * 60 * 1000, // 5 minutes
  USER_ANSWERS: 30 * 60 * 1000, // 30 minutes
} as const;
```

### Background Refetching

```typescript
// hooks/useQuizDataWithRefresh.ts
export const useQuizDataWithRefresh = () => {
  const query = useQuizData();

  const refreshData = useCallback(() => {
    queryClient.invalidateQueries([CACHE_KEYS.QUIZ_DATA]);
  }, []);

  const prefetchNextFlow = useCallback((currentFlow: "flow1" | "flow2") => {
    const nextFlow = currentFlow === "flow1" ? "flow2" : "flow1";
    queryClient.prefetchQuery({
      queryKey: [CACHE_KEYS.QUIZ_DATA, nextFlow],
      queryFn: () => fetchFlowData(nextFlow),
    });
  }, []);

  return {
    ...query,
    refreshData,
    prefetchNextFlow,
  };
};
```

## Optimistic Updates

### Answer Submission

```typescript
// hooks/useQuizAnswers.ts
import { useMutation, useQueryClient } from "@tanstack/react-query";

export const useQuizAnswers = () => {
  const queryClient = useQueryClient();

  const submitAnswerMutation = useMutation({
    mutationFn: async ({
      questionId,
      answer,
    }: {
      questionId: string;
      answer: string;
    }) => {
      // Simulate API call (in real app, this would be actual API)
      await new Promise((resolve) => setTimeout(resolve, 500));
      return { questionId, answer, timestamp: Date.now() };
    },
    onMutate: async ({ questionId, answer }) => {
      // Optimistic update
      queryClient.setQueryData([CACHE_KEYS.USER_ANSWERS], (old: any) => ({
        ...old,
        [questionId]: answer,
      }));
    },
    onError: (error, variables, context) => {
      // Rollback optimistic update on error
      queryClient.invalidateQueries([CACHE_KEYS.USER_ANSWERS]);
    },
  });

  return {
    submitAnswer: submitAnswerMutation.mutate,
    isSubmitting: submitAnswerMutation.isPending,
  };
};
```

## Text Processing

### Error Text Parsing

```typescript
// utils/textParser.ts
export const parseStimulus = (stimulus: string): string => {
  // Convert "*text*" to highlighted error text
  return stimulus.replace(
    /\*(.*?)\*/g,
    '<span class="error-highlight">$1</span>'
  );
};

export const extractError = (stimulus: string): string => {
  const match = stimulus.match(/\*(.*?)\*/);
  return match ? match[1] : "";
};

export const extractCorrectAnswer = (feedback: string): string => {
  const match = feedback.match(/\*(.*?)\*/);
  return match ? match[1] : "";
};

export const compareAnswers = (
  userAnswer: string,
  correctAnswer: string
): boolean => {
  return userAnswer.toLowerCase().trim() === correctAnswer.toLowerCase().trim();
};
```

## API Testing

### Mock Data for Testing

```typescript
// __mocks__/quizApiService.ts
export const mockQuizData: QuizData = {
  name: "Error Find",
  heading: "This game teaches you to find mistakes in written text.",
  activities: [
    {
      activity_name: "Activity One",
      order: 1,
      questions: [
        {
          is_correct: false,
          stimulus: "I really enjoy *to play football* with friends.",
          order: 1,
          user_answers: [],
          feedback: "I really enjoy *playing football* with friends.",
        },
      ],
    },
  ],
};

export const mockUseQuizData = () => ({
  data: mockQuizData,
  isLoading: false,
  error: null,
  refetch: jest.fn(),
});
```

### API Error Simulation

```typescript
// utils/apiErrorSimulator.ts
export const simulateApiError = (
  errorType: "network" | "timeout" | "server"
) => {
  switch (errorType) {
    case "network":
      throw new NetworkError("Network connection failed");
    case "timeout":
      throw new Error("Request timeout");
    case "server":
      throw new Error("Server error: 500");
    default:
      throw new Error("Unknown error");
  }
};
```

## Performance Monitoring

### Query Performance

```typescript
// utils/performanceMonitor.ts
export const logQueryPerformance = (queryKey: string[], duration: number) => {
  if (duration > 1000) {
    console.warn(
      `Slow query detected: ${queryKey.join(".")} took ${duration}ms`
    );
  }
};

// Usage in query
export const useQuizDataWithMonitoring = () => {
  const startTime = performance.now();

  return useQuery({
    queryKey: [CACHE_KEYS.QUIZ_DATA],
    queryFn: async () => {
      const data = await fetchQuizData();
      const duration = performance.now() - startTime;
      logQueryPerformance([CACHE_KEYS.QUIZ_DATA], duration);
      return data;
    },
  });
};
```

## Current Implementation Details

### Flow 1 Implementation

**Data Usage**: Uses all 5 questions from `activities[0].questions`

**Answer Storage**: Uses simple question order as key (`"1"`, `"2"`, etc.)

**Navigation**: Linear progression through all questions regardless of correctness

**Score Calculation**:

```typescript
const calculateScore = () => {
  let correctCount = 0;
  questions.forEach((q: any) => {
    const userAnswer = userAnswers.get(q.order.toString());
    const correctAnswer = q.feedback.replace(/\*([^*]+)\*/g, "$1");
    if (userAnswer === correctAnswer) {
      correctCount++;
    }
  });
  return {
    correct: correctCount,
    total: questions.length,
    percentage: Math.round((correctCount / questions.length) * 100),
  };
};
```

### Flow 2 Implementation

**Data Usage**: Uses first question from each round (`activities[1].questions[round].questions[0]`)

**Answer Storage**: Uses unique keys combining round and question order (`"0-1"`, `"1-1"`, etc.)

**Navigation**: Conditional progression - must answer correctly to proceed to next round

**Score Calculation**: Converts unique keys back to question order for score calculation

```typescript
const scoreAnswers = new Map<string, string>();
userAnswers.forEach((answer, key) => {
  const questionOrder = key.split("-")[1]; // Extract question order
  scoreAnswers.set(questionOrder, answer);
});
const score = calculateScore(scoreAnswers, allQuestions);
```

### Answer Generation

Both flows use intelligent answer generation:

**Flow 1**: Basic alternatives with common patterns
**Flow 2**: Context-aware alternatives based on specific error patterns:

- "haven't finished" ‚Üí "didn't finish", "hasn't finished", "won't finish"
- "like listening" ‚Üí "likes to listen", "like to listen", "likes listening"
- "more cheaper" ‚Üí "more cheap", "cheaper", "most cheap"
- "In the other hand" ‚Üí "On the other hand", "In other hand", "On other hand"

### Score Display

Both flows navigate to the shared `ScorePage` component which displays:

- Correct answers count (e.g., "3 / 5")
- Percentage score
- Encouraging message based on performance
- Navigation back to home
