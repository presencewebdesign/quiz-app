# Quiz Application Architecture

## Overview

This document outlines the architecture of the Error Find Quiz application. The application demonstrates modern React patterns, TypeScript best practices, and scalable architecture principles. The app is deployed on Firebase Hosting and accessible at: **https://quiz-app-98108.web.app**

## Live Application

🌐 **Web App URL**: [https://quiz-app-98108.web.app](https://quiz-app-98108.web.app)

The application is live and fully functional with both quiz flows implemented and working.

## High-Level Architecture

```mermaid
graph TB
    A[User Interface Layer] --> B[Business Logic Layer]
    B --> C[Data Layer]
    C --> D[External API]

    A --> E[React Components]
    A --> F[Suspense Boundaries]
    A --> G[Error Boundaries]

    B --> H[Custom Hooks]
    B --> I[Context Providers]
    B --> J[State Management]

    C --> K[TanStack Query]
    C --> L[API Services]
    C --> M[Data Normalization]
```

## Architecture Principles

### 1. Separation of Concerns

- **Presentation Layer**: UI components and user interactions
- **Business Logic Layer**: Quiz logic, state management, and data processing
- **Data Layer**: API communication, caching, and data transformation

### 2. Component Composition

- **Container Components**: Manage state and business logic
- **Presentational Components**: Focus solely on rendering UI
- **Custom Hooks**: Encapsulate reusable logic

### 3. Data Flow

- **Unidirectional**: Data flows down through props, events flow up through callbacks
- **Centralized State**: Quiz state managed through React Context
- **Optimistic Updates**: Immediate UI feedback with background synchronization

## Project Structure

```
src/
├── components/           # Reusable UI components
│   ├── common/          # Shared components (Button, Loading, etc.)
│   ├── quiz/            # Quiz-specific components
│   └── layout/          # Layout components
├── hooks/               # Custom React hooks
├── services/            # API and external services
├── types/               # TypeScript type definitions
├── utils/               # Utility functions
├── contexts/            # React contexts for state management
├── pages/               # Main application screens
└── styles/              # CSS/styling files
```

## Key Architectural Decisions

### State Management

- **React Context + useReducer**: Sufficient for this application size
- **TanStack Query**: Handles server state and caching
- **Local State**: Component-specific state with useState/useReducer

### Data Fetching

- **Suspense Mode**: Declarative loading states
- **Error Boundaries**: Graceful error handling
- **Optimistic Updates**: Better user experience

### Component Design

- **Composition over Inheritance**: Flexible component composition
- **Props Interface**: Clear component contracts
- **Memoization**: Performance optimization where needed

## Flow Architecture

### Flow 1: Sequential Questions (Implemented)

**Current Implementation**: `src/pages/Flow1Quiz.tsx`

```typescript
interface Flow1Architecture {
  dataSource: "activities[0].questions"; // 5 questions total
  navigation: "linear-progression";
  transitions: "question-to-question (unconditional)";
  scoring: "end-of-flow-with-progress-tracking";
  features: [
    "Progress bar (Question X of 5)",
    "Immediate feedback per question",
    "Score screen with percentage",
    "Sequential navigation regardless of correctness",
    "Multiple choice answer options",
    "Intelligent answer generation",
    "Randomized answer order",
    "Bold highlighting for correct answers",
  ];
  stateManagement: "React Context + useState";
  answerStorage: "Map<string, string> with question order as key";
}
```

**Key Implementation Details**:

- Uses `useQuiz()` context for state management
- Generates 4 answer options per question (1 correct + 3 incorrect)
- Progress tracking with visual progress bar
- Score calculation at the end of all questions
- Navigation to score screen after completion

### Flow 2: Rounds-based Questions (Implemented)

**Current Implementation**: `src/pages/Flow2Quiz.tsx`

```typescript
interface Flow2Architecture {
  dataSource: "activities[1].questions[round].questions[0]"; // First question per round
  navigation: "conditional-round-progression";
  transitions: "question-to-question, round-to-round (conditional)";
  scoring: "end-of-all-rounds-via-score-page";
  features: [
    "Round progress (Round X of Y)",
    "Conditional progression (must pass to proceed)",
    "Unique answer keys (round-questionOrder)",
    "Intelligent answer generation",
    "Score page navigation",
    "Context-aware alternatives",
    "Randomized answer order",
    "Bold highlighting for correct answers",
  ];
  stateManagement: "React Context + useState";
  answerStorage: "Map<string, string> with 'round-questionOrder' format";
}
```

**Key Implementation Details**:

- Uses unique answer keys: `${currentRound}-${question.order}`
- Context-aware answer generation based on error patterns
- Conditional progression - must answer correctly to proceed
- Round-based progress tracking
- Score calculation with unique question identifiers for Flow2 compatibility

## Score Calculation System

### Centralized Score Engine

The application uses a centralized `QuizEngine` class for consistent score calculation across both quiz flows:

```typescript
// services/quizEngine.ts
export class QuizEngine {
  static calculateScore(
    userAnswers: Map<string, string>,
    questions: Question[]
  ): ScoreResult {
    // Handles both Flow1 and Flow2 with unique question identifiers
  }
}
```

### Score Calculation Logic

**Core Algorithm:**

1. **Answer Extraction**: Correct answer extracted from `question.feedback` (asterisks removed)
2. **User Answer Matching**: Direct text comparison between user selection and correct answer
3. **Flow-Specific Handling**:
   - **Flow1**: Uses question `order` as key (`"1"`, `"2"`, `"3"`)
   - **Flow2**: Uses unique identifiers (`"0-1"`, `"1-2"`, `"2-1"`) to handle duplicate question orders across rounds

**Implementation Details:**

```typescript
// For each question:
const questionKey = question.uniqueId || question.order.toString();
const userAnswer = userAnswers.get(questionKey);
const correctAnswerText = question.feedback.replace(/\*([^*]+)\*/g, "$1");

if (userAnswer === correctAnswerText) {
  correct++;
}
```

### Flow-Specific Score Handling

**Flow1 (Sequential Questions):**

- Direct mapping: `userAnswers.get(question.order.toString())`
- Simple key structure: `"1"`, `"2"`, `"3"`

**Flow2 (Rounds-based Questions):**

- Unique identifier generation: `uniqueId: "${roundIndex}-${question.order}"`
- Prevents conflicts when questions across rounds have same order values
- Key conversion: `"0-1"` → matches question with `uniqueId: "0-1"`

### Context Integration

The score calculation is integrated into the `QuizContext`:

```typescript
// contexts/QuizContext.tsx
const calculateScore = (): ScoreResult => {
  if (flow === "flow1") {
    questions = quizData.activities[0]?.questions || [];
    userAnswersForScoring = state.userAnswers;
  } else {
    // Flow2: Generate unique identifiers and collect all questions
    questions = [];
    quizData.activities[1]?.questions?.forEach((round, roundIndex) => {
      round.questions.forEach((question) => {
        questions.push({
          ...question,
          uniqueId: `${roundIndex}-${question.order}`,
        });
      });
    });
    userAnswersForScoring = state.userAnswers; // Keys already in correct format
  }

  return QuizEngine.calculateScore(userAnswersForScoring, questions);
};
```

### Debug and Monitoring

The system includes comprehensive debug logging:

```typescript
console.log("Score Calculation Debug:", {
  flow,
  originalUserAnswers: Array.from(state.userAnswers.entries()),
  convertedUserAnswers: Array.from(userAnswersForScoring.entries()),
  questionsCount: questions.length,
  questions: questions.map((q) => ({
    order: q.order,
    uniqueId: q.uniqueId || q.order.toString(),
    stimulus: q.stimulus,
  })),
  score,
});
```

**Benefits:**

- **Consistency**: Same calculation logic for both flows
- **Accuracy**: Handles Flow2's complex data structure correctly
- **Maintainability**: Centralized logic in QuizEngine
- **Debugging**: Comprehensive logging for troubleshooting
- **Type Safety**: Full TypeScript support with proper interfaces

## Text Processing & User Experience Features

### Answer Randomization

Both quiz flows implement answer randomization to enhance quiz fairness and educational value:

```typescript
// Implementation in both Flow1Quiz and Flow2Quiz
const shuffledOptions = options.slice(0, 4).sort(() => Math.random() - 0.5);
```

**Architecture Benefits:**

- **Fairness**: Prevents pattern recognition from giving unfair advantages
- **Educational Value**: Forces users to actually understand the content
- **Consistency**: Applied uniformly across both quiz flows
- **Performance**: Minimal computational overhead

### Bold Highlighting System

The application uses a sophisticated text processing system to highlight correct answers:

```typescript
// utils/textParser.ts
export const parseFeedback = (feedback: string): string => {
  return feedback.replace(
    /\*([^*]+)\*/g,
    (match, group1) => `<strong>${group1}</strong>`
  );
};
```

**Architecture Benefits:**

- **Data-Driven**: Uses existing JSON asterisk markers
- **Consistent**: Uniform formatting across all feedback displays
- **Maintainable**: Centralized text processing logic
- **Accessible**: Clear visual emphasis for correct answers

### Text Processing Pipeline

```mermaid
graph LR
    A[JSON Data with Asterisks] --> B[parseFeedback Function]
    B --> C[HTML with Bold Tags]
    C --> D[dangerouslySetInnerHTML]
    D --> E[Rendered Bold Text]
```

**Security Considerations:**

- Uses `dangerouslySetInnerHTML` only with controlled, sanitized input
- Asterisk patterns are validated before processing
- No user input is processed through this pipeline

## Error Handling Strategy

### API Errors

- **Retry Logic**: Automatic retry with exponential backoff
- **Fallback UI**: Graceful degradation when API fails
- **User Feedback**: Clear error messages and recovery options

### Runtime Errors

- **Error Boundaries**: Catch and handle component errors
- **Logging**: Error reporting for debugging
- **Recovery**: Reset mechanisms for error states

## Performance Considerations

### Code Splitting

- **Route-based**: Lazy load pages
- **Component-based**: Lazy load heavy components
- **Bundle Analysis**: Monitor bundle size

### Caching Strategy

- **Query Cache**: TanStack Query automatic caching
- **Component Memoization**: Prevent unnecessary re-renders
- **Data Normalization**: Efficient data structures

## Testing Strategy

### Unit Tests

- **Components**: Test individual component behavior
- **Hooks**: Test custom hook logic
- **Utils**: Test utility functions

### Integration Tests

- **User Flows**: Test complete user journeys
- **API Integration**: Test data fetching and error handling
- **State Management**: Test context and state updates

### E2E Tests

- **Critical Paths**: Test main user flows
- **Cross-browser**: Ensure compatibility
- **Performance**: Monitor loading times and responsiveness

## Scalability Considerations

### Future Enhancements

- **New Question Types**: Extensible question component system
- **Additional Flows**: Flexible flow management system
- **Analytics**: Built-in analytics hooks
- **Accessibility**: WCAG compliance framework

### Performance Monitoring

- **Bundle Size**: Regular bundle analysis
- **Runtime Performance**: React DevTools profiling
- **User Experience**: Core Web Vitals monitoring

## Security Considerations

### Data Protection

- **Input Validation**: Sanitize user inputs
- **XSS Prevention**: Safe HTML rendering
- **CSRF Protection**: Secure API communication

### Privacy

- **Data Minimization**: Only collect necessary data
- **Local Storage**: Secure local data storage
- **Session Management**: Proper session handling
