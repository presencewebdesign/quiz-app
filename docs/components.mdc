# Components Documentation

## Live Application

🌐 **Web App URL**: [https://quiz-app-98108.web.app](https://quiz-app-98108.web.app)

## Component Architecture Overview

The quiz application follows a component-based architecture with clear separation of concerns. Components are organized into logical groups and follow consistent patterns for reusability and maintainability. The current implementation includes fully functional Flow1Quiz and Flow2Quiz components with intelligent answer generation and proper state management.

## Component Hierarchy

```mermaid
graph TD
    A[App] --> B[Router]
    B --> C[HomePage]
    B --> D[QuizPage]
    B --> E[ScorePage]

    D --> F[QuizProvider]
    F --> G[Flow1Quiz]
    F --> H[Flow2Quiz]

    G --> I[ErrorFindQuestion]
    G --> J[ProgressBar]
    G --> K[NavigationButtons]

    H --> I
    H --> J
    H --> K
    H --> L[RoundTransition]

    I --> M[TextInput]
    I --> N[FeedbackDisplay]
    I --> O[ErrorHighlight]
```

## Component Categories

### Layout Components

Components responsible for overall page structure and layout.

#### Layout

```typescript
// components/layout/Layout.tsx
interface LayoutProps {
  children: React.ReactNode;
  title?: string;
}

export const Layout = ({ children, title }: LayoutProps) => (
  <div className="layout">
    <header className="header">
      <h1>{title || "Error Find Quiz"}</h1>
    </header>
    <main className="main">{children}</main>
    <footer className="footer">
      <p>Error Find Quiz Application</p>
    </footer>
  </div>
);
```

#### Header

```typescript
// components/layout/Header.tsx
interface HeaderProps {
  title: string;
  showProgress?: boolean;
  progress?: number;
}

export const Header = ({ title, showProgress, progress }: HeaderProps) => (
  <header className="header">
    <h1 className="title">{title}</h1>
    {showProgress && (
      <div className="progress-container">
        <ProgressBar progress={progress || 0} />
      </div>
    )}
  </header>
);
```

### Common Components

Reusable components used throughout the application.

#### Button

```typescript
// components/common/Button.tsx
interface ButtonProps {
  children: React.ReactNode;
  onClick?: () => void;
  variant?: "primary" | "secondary" | "danger";
  size?: "small" | "medium" | "large";
  disabled?: boolean;
  loading?: boolean;
}

export const Button = ({
  children,
  onClick,
  variant = "primary",
  size = "medium",
  disabled = false,
  loading = false,
}: ButtonProps) => (
  <button
    className={`btn btn-${variant} btn-${size}`}
    onClick={onClick}
    disabled={disabled || loading}
  >
    {loading ? <Spinner /> : children}
  </button>
);
```

#### Loading Spinner

```typescript
// components/common/LoadingSpinner.tsx
interface LoadingSpinnerProps {
  size?: "small" | "medium" | "large";
  color?: string;
}

export const LoadingSpinner = ({
  size = "medium",
  color = "#007bff",
}: LoadingSpinnerProps) => (
  <div className={`spinner spinner-${size}`} style={{ color }}>
    <div className="spinner-inner" />
  </div>
);
```

#### Progress Bar

```typescript
// components/common/ProgressBar.tsx
interface ProgressBarProps {
  progress: number; // 0-100
  showPercentage?: boolean;
  color?: string;
}

export const ProgressBar = ({
  progress,
  showPercentage = false,
  color,
}: ProgressBarProps) => (
  <div className="progress-bar">
    <div
      className="progress-fill"
      style={{
        width: `${Math.min(100, Math.max(0, progress))}%`,
        backgroundColor: color,
      }}
    />
    {showPercentage && (
      <span className="progress-text">{Math.round(progress)}%</span>
    )}
  </div>
);
```

### Quiz Components

Components specific to quiz functionality.

#### ErrorFindQuestion

```typescript
// components/quiz/ErrorFindQuestion.tsx
interface ErrorFindQuestionProps {
  question: Question;
  onAnswer: (answer: string) => void;
  showFeedback: boolean;
  userAnswer?: string;
  isSubmitting?: boolean;
}

export const ErrorFindQuestion = ({
  question,
  onAnswer,
  showFeedback,
  userAnswer,
  isSubmitting = false,
}: ErrorFindQuestionProps) => {
  const [inputValue, setInputValue] = useState(userAnswer || "");

  const handleSubmit = useCallback(() => {
    if (inputValue.trim()) {
      onAnswer(inputValue.trim());
    }
  }, [inputValue, onAnswer]);

  const handleKeyPress = useCallback(
    (e: KeyboardEvent) => {
      if (e.key === "Enter") {
        handleSubmit();
      }
    },
    [handleSubmit]
  );

  return (
    <div className="error-find-question">
      <div className="question-header">
        <h3>Find the Error</h3>
        <p>
          Identify the mistake in the text below and provide the correction.
        </p>
      </div>

      <div className="stimulus-text">
        <ErrorHighlight text={question.stimulus} />
      </div>

      <div className="input-section">
        <TextInput
          value={inputValue}
          onChange={setInputValue}
          onKeyPress={handleKeyPress}
          placeholder="Enter your correction..."
          disabled={isSubmitting}
        />

        <Button
          onClick={handleSubmit}
          disabled={!inputValue.trim() || isSubmitting}
          loading={isSubmitting}
        >
          Submit Answer
        </Button>
      </div>

      {showFeedback && (
        <FeedbackDisplay question={question} userAnswer={userAnswer} />
      )}
    </div>
  );
};
```

#### ErrorHighlight

```typescript
// components/quiz/ErrorHighlight.tsx
interface ErrorHighlightProps {
  text: string;
  highlightClass?: string;
}

export const ErrorHighlight = ({
  text,
  highlightClass = "error-highlight",
}: ErrorHighlightProps) => {
  const parseText = useCallback(
    (text: string) => {
      // Convert "*text*" to highlighted spans
      const parts = text.split(/(\*.*?\*)/g);

      return parts.map((part, index) => {
        if (part.startsWith("*") && part.endsWith("*")) {
          const errorText = part.slice(1, -1);
          return (
            <span key={index} className={highlightClass}>
              {errorText}
            </span>
          );
        }
        return part;
      });
    },
    [highlightClass]
  );

  return <div className="error-highlight-container">{parseText(text)}</div>;
};
```

#### TextInput

```typescript
// components/quiz/TextInput.tsx
interface TextInputProps {
  value: string;
  onChange: (value: string) => void;
  onKeyPress?: (e: KeyboardEvent) => void;
  placeholder?: string;
  disabled?: boolean;
  maxLength?: number;
}

export const TextInput = ({
  value,
  onChange,
  onKeyPress,
  placeholder,
  disabled = false,
  maxLength,
}: TextInputProps) => (
  <input
    type="text"
    value={value}
    onChange={(e) => onChange(e.target.value)}
    onKeyPress={onKeyPress}
    placeholder={placeholder}
    disabled={disabled}
    maxLength={maxLength}
    className="text-input"
  />
);
```

#### FeedbackDisplay

```typescript
// components/quiz/FeedbackDisplay.tsx
interface FeedbackDisplayProps {
  question: Question;
  userAnswer?: string;
}

export const FeedbackDisplay = ({
  question,
  userAnswer,
}: FeedbackDisplayProps) => {
  const isCorrect = useMemo(() => {
    if (!userAnswer) return false;
    const correctAnswer = extractCorrectAnswer(question.feedback);
    return compareAnswers(userAnswer, correctAnswer);
  }, [question.feedback, userAnswer]);

  return (
    <div className={`feedback-display ${isCorrect ? "correct" : "incorrect"}`}>
      <div className="feedback-header">
        <h4>{isCorrect ? "Correct!" : "Incorrect"}</h4>
        <span className="feedback-icon">{isCorrect ? "✓" : "✗"}</span>
      </div>

      <div className="feedback-content">
        <div className="user-answer">
          <strong>Your answer:</strong> {userAnswer || "No answer provided"}
        </div>

        <div className="correct-answer">
          <strong>Correct answer:</strong>
          <ErrorHighlight text={question.feedback} />
        </div>

        {question.is_correct && (
          <div className="explanation">
            <strong>Explanation:</strong> The text is already correct.
          </div>
        )}
      </div>
    </div>
  );
};
```

#### RoundTransition

```typescript
// components/quiz/RoundTransition.tsx
interface RoundTransitionProps {
  currentRound: number;
  totalRounds: number;
  onNextRound: () => void;
  onFinish: () => void;
}

export const RoundTransition = ({
  currentRound,
  totalRounds,
  onNextRound,
  onFinish,
}: RoundTransitionProps) => {
  const isLastRound = currentRound >= totalRounds;

  return (
    <div className="round-transition">
      <div className="transition-content">
        <h3>Round {currentRound} Complete!</h3>
        <p>
          {isLastRound
            ? "You have completed all rounds. Ready to see your score?"
            : `Great job! You've completed Round ${currentRound}. Ready for the next round?`}
        </p>

        <div className="transition-actions">
          <Button
            onClick={isLastRound ? onFinish : onNextRound}
            variant="primary"
            size="large"
          >
            {isLastRound ? "View Score" : "Next Round"}
          </Button>
        </div>
      </div>
    </div>
  );
};
```

#### NavigationButtons

```typescript
// components/quiz/NavigationButtons.tsx
interface NavigationButtonsProps {
  onPrevious: () => void;
  onNext: () => void;
  onFinish: () => void;
  showPrevious: boolean;
  showNext: boolean;
  showFinish: boolean;
  isSubmitting?: boolean;
}

export const NavigationButtons = ({
  onPrevious,
  onNext,
  onFinish,
  showPrevious,
  showNext,
  showFinish,
  isSubmitting = false,
}: NavigationButtonsProps) => (
  <div className="navigation-buttons">
    <div className="nav-left">
      {showPrevious && (
        <Button
          onClick={onPrevious}
          variant="secondary"
          disabled={isSubmitting}
        >
          Previous
        </Button>
      )}
    </div>

    <div className="nav-right">
      {showNext && (
        <Button onClick={onNext} disabled={isSubmitting}>
          Next
        </Button>
      )}

      {showFinish && (
        <Button onClick={onFinish} variant="primary" disabled={isSubmitting}>
          Finish Quiz
        </Button>
      )}
    </div>
  </div>
);
```

### Page Components

Main application screens.

#### HomePage

```typescript
// pages/HomePage.tsx
export const HomePage = () => {
  const navigate = useNavigate();

  const handleFlow1 = () => navigate("/quiz/flow1");
  const handleFlow2 = () => navigate("/quiz/flow2");

  return (
    <Layout title="Error Find Quiz">
      <div className="home-page">
        <div className="welcome-section">
          <h2>Welcome to Error Find!</h2>
          <p>This game teaches you to find mistakes in written text.</p>
        </div>

        <div className="flow-selection">
          <div className="flow-card">
            <h3>Flow 1: Sequential Questions</h3>
            <p>Answer all 5 questions in sequence with progress tracking, then see your score.</p>
            <Button onClick={handleFlow1} size="large">
              Start Flow 1
            </Button>
          </div>

          <div className="flow-card">
            <h3>Flow 2: Rounds-based Questions</h3>
            <p>Complete rounds sequentially - must pass each round to proceed to the next.</p>
            <Button onClick={handleFlow2} size="large">
              Start Flow 2
            </Button>
          </div>
        </div>
      </div>
    </Layout>
  );
};
```

#### QuizPage

```typescript
// pages/QuizPage.tsx
export const QuizPage = () => {
  const { flow } = useParams<{ flow: "flow1" | "flow2" }>();

  if (!flow || !["flow1", "flow2"].includes(flow)) {
    return <Navigate to="/" replace />;
  }

  return (
    <Layout>
      <Suspense fallback={<QuizLoadingSkeleton />}>
        <QuizContent flow={flow} />
      </Suspense>
    </Layout>
  );
};

const QuizContent = ({ flow }: { flow: "flow1" | "flow2" }) => {
  const { data: quizData } = useQuizData();

  return (
    <QuizProvider quizData={quizData}>
      {flow === "flow1" ? <Flow1Quiz /> : <Flow2Quiz />}
    </QuizProvider>
  );
};
```

#### Flow1Quiz - Sequential Questions

The Flow1Quiz component handles the sequential question flow where users answer all 5 questions from Activity One in order, with progress tracking and immediate feedback.

```typescript
// pages/Flow1Quiz.tsx
export const Flow1Quiz = () => {
  const navigate = useNavigate();
  const { quizData, userAnswers, setAnswer } = useQuiz();

  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [showScore, setShowScore] = useState(false);

  const activity = quizData.activities[0]; // Activity One
  const questions = activity.questions; // All 5 questions
  const currentQuestion = questions[currentQuestionIndex];
  const isLastQuestion = currentQuestionIndex === questions.length - 1;

  // Generate 4 answer options (1 correct + 3 incorrect) with randomization
  const generateAnswerOptions = (question: any) => {
    const options: Array<{ value: string; label: string; isCorrect: boolean }> = [];

    // Add correct answer from feedback
    const correctAnswer = question.feedback.replace(/\*([^*]+)\*/g, '$1');
    options.push({ value: correctAnswer, label: correctAnswer, isCorrect: true });

    // Add incorrect answer from stimulus
    const incorrectAnswer = question.stimulus.replace(/\*([^*]+)\*/g, '$1');
    if (incorrectAnswer !== correctAnswer) {
      options.push({ value: incorrectAnswer, label: incorrectAnswer, isCorrect: false });
    }

    // Add common alternatives for variety
    const alternatives = [
      question.stimulus.replace(/\*([^*]+)\*/g, 'playing'),
      question.stimulus.replace(/\*([^*]+)\*/g, 'to play'),
      question.stimulus.replace(/\*([^*]+)\*/g, 'play'),
    ];

    alternatives.forEach(alt => {
      if (alt !== correctAnswer && alt !== incorrectAnswer && !options.find(opt => opt.value === alt)) {
        options.push({ value: alt, label: alt, isCorrect: false });
      }
    });

    // Randomize the order of options to prevent easy guessing
    const shuffledOptions = options.slice(0, 4).sort(() => Math.random() - 0.5);

    return shuffledOptions;
  };

  const handleAnswer = (answer: string) => {
    setAnswer(currentQuestion.order.toString(), answer);
  };

  const handleNextQuestion = () => {
    if (isLastQuestion) {
      setShowScore(true); // Show score screen
    } else {
      setCurrentQuestionIndex(currentQuestionIndex + 1);
    }
  };

  const calculateScore = () => {
    let correctCount = 0;
    questions.forEach((q: any) => {
      const userAnswer = userAnswers.get(q.order.toString());
      const correctAnswer = q.feedback.replace(/\*([^*]+)\*/g, '$1');
      if (userAnswer === correctAnswer) {
        correctCount++;
      }
    });
    return {
      correct: correctCount,
      total: questions.length,
      percentage: Math.round((correctCount / questions.length) * 100)
    };
  };

  // Show score screen after all questions
  if (showScore) {
    const score = calculateScore();
    return (
      <div className={styles.flow1Quiz}>
        <div className={styles.header}>
          <h1>{quizData.heading}</h1>
          <h2>{activity.activity_name} - Complete!</h2>
        </div>
        <div className={styles.scoreContainer}>
          <div className={styles.scoreCard}>
            <h2>🎉 Quiz Complete!</h2>
            <div className={styles.scoreResults}>
              <div className={styles.scoreNumber}>{score.correct} / {score.total}</div>
              <div className={styles.scorePercentage}>{score.percentage}%</div>
            </div>
            <p className={styles.scoreMessage}>
              You answered {score.correct} out of {score.total} questions correctly.
            </p>
            <div className={styles.navigation}>
              <Button onClick={() => navigate("/")} variant="primary">
                Back to Home
              </Button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Main question interface
  return (
    <div className={styles.flow1Quiz}>
      <div className={styles.header}>
        <h1>{quizData.heading}</h1>
        <h2>{activity.activity_name}</h2>
        <div className={styles.progressContainer}>
          <div className={styles.questionInfo}>
            Question {currentQuestionIndex + 1} of {questions.length}
          </div>
          <ProgressBar progress={((currentQuestionIndex + 1) / questions.length) * 100} showPercentage />
        </div>
      </div>

      <div className={styles.questionContainer}>
        <div className={styles.questionCard}>
          <div className={styles.questionText}>
            <p className={styles.stimulus}>{displayStimulus}</p>
          </div>

          {!userAnswer ? (
            <div className={styles.answerOptions}>
              <h4>Choose the correct version:</h4>
              {generateAnswerOptions(currentQuestion).map((option, index) => (
                <label key={index} className={styles.radioOption}>
                  <input
                    type="radio"
                    name={`question-${currentQuestion.order}`}
                    value={option.value}
                    checked={userAnswer === option.value}
                    onChange={() => handleAnswer(option.value)}
                  />
                  <span className={styles.radioLabel}>{option.label}</span>
                </label>
              ))}
            </div>
          ) : (
            <div className={styles.result}>
              {isCorrect ? (
                <div className={styles.congratulations}>
                  <h3>🎉 Correct!</h3>
                  <p>You selected the right answer.</p>
                </div>
              ) : (
                <div className={styles.incorrect}>
                  <h3>❌ Incorrect</h3>
                  <p>The correct answer is: <span dangerouslySetInnerHTML={{ __html: parseFeedback(currentQuestion.feedback) }} /></p>
                </div>
              )}
            </div>
          )}
        </div>

        <div className={styles.navigation}>
          <Button onClick={() => navigate("/")} variant="secondary">
            Back to Home
          </Button>
          {userAnswer && (
            <Button onClick={handleNextQuestion} variant="primary">
              {isLastQuestion ? "Finish Quiz" : "Next Question"}
            </Button>
          )}
        </div>
      </div>
    </div>
  );
};
```

**Key Features:**

- **Sequential Navigation**: Users progress through all 5 questions regardless of correctness
- **Progress Tracking**: Visual progress bar showing "Question X of 5"
- **Immediate Feedback**: Shows correct/incorrect status after each answer
- **Score Calculation**: Calculates final score based on all answers
- **Score Screen**: Displays comprehensive results at the end
- **No Error Hints**: Stimulus text displayed without asterisks for increased difficulty
- **Randomized Answers**: Answer options are shuffled to prevent easy guessing
- **Bold Highlighting**: Correct answers in feedback are displayed in **bold** using asterisks from JSON

#### Flow2Quiz - Rounds-based Questions

The Flow2Quiz component handles the rounds-based flow where users must complete each round correctly to proceed to the next round.

```typescript
// pages/Flow2Quiz.tsx
export const Flow2Quiz = () => {
  const navigate = useNavigate();
  const { quizData, userAnswers, setAnswer, currentRound, nextRound } = useQuiz();

  const activity = quizData.activities[1]; // Activity Two
  const currentRoundData = activity.questions[currentRound];
  const question = currentRoundData.questions[0]; // First question of current round
  const isLastRound = currentRound === activity.questions.length - 1;

  // Generate intelligent answer options based on question patterns with randomization
  const generateAnswerOptions = (question: any) => {
    const options: Array<{ value: string; label: string; isCorrect: boolean }> = [];

    const correctAnswer = question.feedback.replace(/\*([^*]+)\*/g, '$1');
    options.push({ value: correctAnswer, label: correctAnswer, isCorrect: true });

    const incorrectAnswer = question.stimulus.replace(/\*([^*]+)\*/g, '$1');
    if (incorrectAnswer !== correctAnswer) {
      options.push({ value: incorrectAnswer, label: incorrectAnswer, isCorrect: false });
    }

    // Generate intelligent alternatives based on common error patterns
    const alternatives = [];
    if (question.stimulus.includes("haven't finished")) {
      alternatives.push(
        question.stimulus.replace(/\*([^*]+)\*/g, "didn't finish"),
        question.stimulus.replace(/\*([^*]+)\*/g, "hasn't finished"),
        question.stimulus.replace(/\*([^*]+)\*/g, "won't finish")
      );
    } else if (question.stimulus.includes("like listening")) {
      alternatives.push(
        question.stimulus.replace(/\*([^*]+)\*/g, "likes to listen"),
        question.stimulus.replace(/\*([^*]+)\*/g, "like to listen"),
        question.stimulus.replace(/\*([^*]+)\*/g, "likes listening")
      );
    } else if (question.stimulus.includes("more cheaper")) {
      alternatives.push(
        question.stimulus.replace(/\*([^*]+)\*/g, "more cheap"),
        question.stimulus.replace(/\*([^*]+)\*/g, "cheaper"),
        question.stimulus.replace(/\*([^*]+)\*/g, "most cheap")
      );
    } else if (question.stimulus.includes("In the other hand")) {
      alternatives.push(
        question.stimulus.replace(/\*([^*]+)\*/g, "On the other hand"),
        question.stimulus.replace(/\*([^*]+)\*/g, "In other hand"),
        question.stimulus.replace(/\*([^*]+)\*/g, "On other hand")
      );
    } else {
      alternatives.push(
        question.stimulus.replace(/\*([^*]+)\*/g, 'playing'),
        question.stimulus.replace(/\*([^*]+)\*/g, 'to play'),
        question.stimulus.replace(/\*([^*]+)\*/g, 'play')
      );
    }

    alternatives.forEach(alt => {
      if (alt !== correctAnswer && alt !== incorrectAnswer && !options.find(opt => opt.value === alt)) {
        options.push({ value: alt, label: alt, isCorrect: false });
      }
    });

    // Randomize the order of options to prevent easy guessing
    const shuffledOptions = options.slice(0, 4).sort(() => Math.random() - 0.5);

    return shuffledOptions;
  };

  const handleAnswer = (answer: string) => {
    // Use unique key combining round and question order
    const uniqueKey = `${currentRound}-${question.order}`;
    setAnswer(uniqueKey, answer);
  };

  const handleNextRound = () => {
    if (isLastRound) {
      // Calculate final score and navigate to score page
      const allQuestions = activity.questions.map(round => round.questions[0]);

      // Convert userAnswers to use question order as key for score calculation
      const scoreAnswers = new Map<string, string>();
      userAnswers.forEach((answer, key) => {
        const questionOrder = key.split('-')[1];
        scoreAnswers.set(questionOrder, answer);
      });

      const score = calculateScore(scoreAnswers, allQuestions);
      navigate("/score", { state: { score, flow: "flow2" } });
    } else {
      // Only allow progression if current round is completed correctly
      if (isCorrect) {
        nextRound();
      }
    }
  };

  const uniqueKey = `${currentRound}-${question.order}`;
  const userAnswer = userAnswers.get(uniqueKey);
  const correctAnswer = question.feedback.replace(/\*([^*]+)\*/g, '$1');
  const isCorrect = userAnswer ? userAnswer === correctAnswer : false;
  const overallProgress = ((currentRound + 1) / activity.questions.length) * 100;

  return (
    <div className={styles.flow2Quiz}>
      <div className={styles.header}>
        <h1>{quizData.heading}</h1>
        <h2>{activity.activity_name}</h2>
        <div className={styles.progressContainer}>
          <div className={styles.roundInfo}>
            Round {currentRound + 1} of {activity.questions.length}
          </div>
          <ProgressBar progress={overallProgress} showPercentage />
        </div>
      </div>

      <div className={styles.questionContainer}>
        <div className={styles.questionCard}>
          <div className={styles.questionText}>
            <h3>Round {currentRound + 1}: {currentRoundData.round_title}</h3>
            <p className={styles.stimulus}>{question.stimulus}</p>
          </div>

          {!userAnswer ? (
            <div className={styles.answerOptions}>
              <h4>Choose the correct version:</h4>
              {generateAnswerOptions(question).map((option, index) => (
                <label key={index} className={styles.radioOption}>
                  <input
                    type="radio"
                    name={`question-${question.order}`}
                    value={option.value}
                    checked={userAnswer === option.value}
                    onChange={() => handleAnswer(option.value)}
                  />
                  <span className={styles.radioLabel}>{option.label}</span>
                </label>
              ))}
            </div>
          ) : (
            <div className={styles.result}>
              {isCorrect ? (
                <div className={styles.congratulations}>
                  <h3>🎉 Congratulations! You passed Round {currentRound + 1}!</h3>
                  <p>Great job! You can now proceed to the next round.</p>
                </div>
              ) : (
                <div className={styles.incorrect}>
                  <h3>❌ Incorrect. Better luck next time!</h3>
                  <p>The correct answer is: <span dangerouslySetInnerHTML={{ __html: parseFeedback(question.feedback) }} /></p>
                </div>
              )}
            </div>
          )}
        </div>

        <div className={styles.navigation}>
          <Button onClick={() => navigate("/")} variant="secondary">
            Back to Home
          </Button>
          {userAnswer && (
            <Button onClick={handleNextRound} variant="primary">
              {isLastRound ? "Finish Quiz" : "Next Round"}
            </Button>
          )}
        </div>
      </div>
    </div>
  );
};
```

**Key Features:**

- **Round-based Progression**: Must complete each round correctly to proceed
- **Unique Answer Keys**: Uses `"round-questionOrder"` format to prevent key collisions
- **Intelligent Alternatives**: Generates contextually relevant incorrect options
- **Round Progress**: Shows "Round X of Y" with overall progress
- **Score Navigation**: Navigates to shared ScorePage component
- **No Error Hints**: Stimulus text displayed without asterisks for increased difficulty
- **Randomized Answers**: Answer options are shuffled to prevent easy guessing
- **Bold Highlighting**: Correct answers in feedback are displayed in **bold** using asterisks from JSON
- **Exit Option**: "Back to Home" button allows users to exit the quiz at any time

#### ScorePage

```typescript
// pages/ScorePage.tsx
export const ScorePage = () => {
  const navigate = useNavigate();
  const { score, totalQuestions, percentage } = useScoreCalculation();

  const handleRestart = () => {
    navigate("/");
  };

  return (
    <Layout title="Quiz Complete">
      <div className="score-page">
        <div className="score-header">
          <h2>Quiz Complete!</h2>
          <p>Here are your results:</p>
        </div>

        <div className="score-display">
          <div className="score-circle">
            <span className="score-percentage">{percentage}%</span>
          </div>

          <div className="score-details">
            <p>
              <strong>Correct Answers:</strong> {score}
            </p>
            <p>
              <strong>Total Questions:</strong> {totalQuestions}
            </p>
            <p>
              <strong>Percentage:</strong> {percentage}%
            </p>
          </div>
        </div>

        <div className="score-actions">
          <Button onClick={handleRestart} size="large">
            Take Another Quiz
          </Button>
        </div>
      </div>
    </Layout>
  );
};
```

## Text Processing Utilities

The application includes specialized text processing utilities for handling quiz content and feedback display.

### Text Parser Functions

```typescript
// utils/textParser.ts

// Parse stimulus text to highlight errors
export const parseStimulus = (stimulus: string): string => {
  // Convert "*text*" to highlighted error text
  return stimulus.replace(
    /\*(.*?)\*/g,
    '<span class="error-highlight">$1</span>'
  );
};

// Parse feedback text to highlight correct answers in bold
export const parseFeedback = (feedback: string): string => {
  // Convert "*text*" to bold text
  return feedback.replace(
    /\*([^*]+)\*/g,
    (match, group1) => `<strong>${group1}</strong>`
  );
};

// Extract the error text for comparison
export const extractError = (stimulus: string): string => {
  const match = stimulus.match(/\*(.*?)\*/);
  return match ? match[1] : "";
};

// Extract correct answer from feedback
export const extractCorrectAnswer = (feedback: string): string => {
  const match = feedback.match(/\*(.*?)\*/);
  return match ? match[1] : "";
};

// Compare user answer with correct answer
export const compareAnswers = (
  userAnswer: string,
  correctAnswer: string
): boolean => {
  return userAnswer.toLowerCase().trim() === correctAnswer.toLowerCase().trim();
};

// Calculate score based on answers
export const calculateScore = (
  userAnswers: Map<string, string>,
  questions: any[]
): { correct: number; total: number; percentage: number } => {
  let correct = 0;

  questions.forEach((question) => {
    const userAnswer = userAnswers.get(question.order.toString());
    if (userAnswer) {
      // Get the correct answer from feedback (remove asterisks)
      const correctAnswer = question.feedback.replace(/\*([^*]+)\*/g, "$1");

      // Compare user answer with correct answer
      if (userAnswer === correctAnswer) {
        correct++;
      }
    }
  });

  return {
    correct,
    total: questions.length,
    percentage: Math.round((correct / questions.length) * 100),
  };
};
```

### Answer Randomization

Both quiz flows implement answer randomization to prevent easy guessing:

```typescript
// Randomize the order of options to prevent easy guessing
const shuffledOptions = options.slice(0, 4).sort(() => Math.random() - 0.5);
return shuffledOptions;
```

**Benefits:**

- Prevents users from always selecting the first option
- Increases quiz difficulty and fairness
- Maintains educational value by requiring actual knowledge

### Bold Highlighting Implementation

Correct answers in feedback are displayed with bold formatting using the asterisks from the original JSON data:

```typescript
// Usage in components
<p>The correct answer is: <span dangerouslySetInnerHTML={{ __html: parseFeedback(question.feedback) }} /></p>
```

**Example:**

- Original feedback: `"The correct answer is *playing* football."`
- Rendered output: `"The correct answer is **playing** football."`

**Benefits:**

- Visual emphasis on correct answers
- Uses existing JSON data structure
- Consistent formatting across both quiz flows

## Component Patterns

### Container-Presenter Pattern

```typescript
// Container manages state and logic
const QuizContainer = () => {
  const { data, isLoading, error } = useQuizData();

  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorDisplay error={error} />;

  return <QuizPresenter data={data} />;
};

// Presenter focuses on rendering
const QuizPresenter = ({ data }: { data: QuizData }) => (
  <div className="quiz-presenter">{/* Pure UI rendering */}</div>
);
```

### Compound Components

```typescript
// components/quiz/QuestionCard.tsx
const QuestionCard = ({ children }: { children: React.ReactNode }) => (
  <div className="question-card">{children}</div>
);

QuestionCard.Header = ({ children }: { children: React.ReactNode }) => (
  <div className="question-header">{children}</div>
);

QuestionCard.Content = ({ children }: { children: React.ReactNode }) => (
  <div className="question-content">{children}</div>
);

QuestionCard.Footer = ({ children }: { children: React.ReactNode }) => (
  <div className="question-footer">{children}</div>
);

// Usage
<QuestionCard>
  <QuestionCard.Header>
    <h3>Question 1</h3>
  </QuestionCard.Header>
  <QuestionCard.Content>
    <ErrorFindQuestion question={question} />
  </QuestionCard.Content>
  <QuestionCard.Footer>
    <NavigationButtons />
  </QuestionCard.Footer>
</QuestionCard>;
```

### Render Props Pattern

```typescript
// components/common/DataFetcher.tsx
interface DataFetcherProps<T> {
  queryKey: string[];
  queryFn: () => Promise<T>;
  children: (data: {
    data: T;
    loading: boolean;
    error: Error | null;
  }) => React.ReactNode;
}

export const DataFetcher = <T>({
  queryKey,
  queryFn,
  children,
}: DataFetcherProps<T>) => {
  const { data, isLoading, error } = useQuery({
    queryKey,
    queryFn,
  });

  return <>{children({ data, loading: isLoading, error })}</>;
};
```

## Styling Guidelines

### SCSS Modules

```scss
/* components/quiz/ErrorFindQuestion.module.scss */
@import "../../styles/variables";
@import "../../styles/mixins";

.errorFindQuestion {
  padding: $spacing-xl;
  border: 1px solid lighten($secondary-color, 30%);
  border-radius: $border-radius;
  background: white;
  box-shadow: $box-shadow;

  .questionHeader {
    margin-bottom: $spacing-lg;

    h3 {
      color: $primary-color;
      font-size: 1.5rem;
      margin-bottom: $spacing-sm;
    }
  }

  .stimulusText {
    font-size: 1.2rem;
    line-height: $line-height-base;
    margin-bottom: $spacing-xl;
    padding: $spacing-md;
    background: lighten($secondary-color, 45%);
    border-radius: $border-radius;

    .errorHighlight {
      background-color: lighten($danger-color, 40%);
      padding: 2px 4px;
      border-radius: 2px;
      font-weight: bold;
    }
  }

  .inputSection {
    display: flex;
    gap: $spacing-md;
    align-items: center;

    @include respond-to(md) {
      flex-direction: column;
      align-items: stretch;
    }
  }

  .textInput {
    flex: 1;
    padding: $spacing-sm $spacing-md;
    border: 1px solid lighten($secondary-color, 20%);
    border-radius: $border-radius;
    font-size: $font-size-base;
    transition: border-color 0.2s ease;

    &:focus {
      outline: none;
      border-color: $primary-color;
      box-shadow: 0 0 0 2px rgba($primary-color, 0.25);
    }
  }
}
```

### SCSS Variables & Design System

```scss
/* styles/_variables.scss */
// Color Palette
$primary-color: #007bff;
$secondary-color: #6c757d;
$success-color: #28a745;
$danger-color: #dc3545;
$warning-color: #ffc107;
$info-color: #17a2b8;

// Typography
$font-family-base:
  -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
$font-size-base: 16px;
$line-height-base: 1.5;

// Spacing Scale
$spacing-xs: 0.25rem;
$spacing-sm: 0.5rem;
$spacing-md: 1rem;
$spacing-lg: 1.5rem;
$spacing-xl: 2rem;

// Design Tokens
$border-radius: 4px;
$box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);

// Breakpoints
$breakpoint-sm: 576px;
$breakpoint-md: 768px;
$breakpoint-lg: 992px;
$breakpoint-xl: 1200px;

// Component-specific Variables
$button-padding: $spacing-sm $spacing-md;
$input-padding: $spacing-sm $spacing-md;
$card-padding: $spacing-xl;
```

### SCSS Mixins

```scss
/* styles/_mixins.scss */
// Responsive Breakpoints
@mixin respond-to($breakpoint) {
  @if $breakpoint == sm {
    @media (min-width: $breakpoint-sm) {
      @content;
    }
  }
  @if $breakpoint == md {
    @media (min-width: $breakpoint-md) {
      @content;
    }
  }
  @if $breakpoint == lg {
    @media (min-width: $breakpoint-lg) {
      @content;
    }
  }
  @if $breakpoint == xl {
    @media (min-width: $breakpoint-xl) {
      @content;
    }
  }
}

// Button Variants
@mixin button-variant($bg-color, $text-color: white) {
  background-color: $bg-color;
  color: $text-color;
  border: 1px solid $bg-color;

  &:hover {
    background-color: darken($bg-color, 10%);
    border-color: darken($bg-color, 10%);
  }

  &:disabled {
    background-color: lighten($bg-color, 20%);
    border-color: lighten($bg-color, 20%);
    opacity: 0.6;
  }
}

// Focus States
@mixin focus-ring($color: $primary-color) {
  &:focus {
    outline: none;
    border-color: $color;
    box-shadow: 0 0 0 2px rgba($color, 0.25);
  }
}

// Card Styles
@mixin card-style {
  background: white;
  border: 1px solid lighten($secondary-color, 30%);
  border-radius: $border-radius;
  box-shadow: $box-shadow;
  padding: $card-padding;
}
```

## Testing Components

### Component Testing Setup

```typescript
// __tests__/components/ErrorFindQuestion.test.tsx
import { render, screen, fireEvent } from "@testing-library/react";
import { ErrorFindQuestion } from "../components/quiz/ErrorFindQuestion";

const mockQuestion = {
  is_correct: false,
  stimulus: "I really enjoy *to play football* with friends.",
  order: 1,
  user_answers: [],
  feedback: "I really enjoy *playing football* with friends.",
};

describe("ErrorFindQuestion", () => {
  it("renders question stimulus with error highlighting", () => {
    render(
      <ErrorFindQuestion
        question={mockQuestion}
        onAnswer={jest.fn()}
        showFeedback={false}
      />
    );

    expect(screen.getByText(/I really enjoy/)).toBeInTheDocument();
    expect(screen.getByText("to play football")).toHaveClass("error-highlight");
  });

  it("calls onAnswer when submit button is clicked", () => {
    const mockOnAnswer = jest.fn();
    render(
      <ErrorFindQuestion
        question={mockQuestion}
        onAnswer={mockOnAnswer}
        showFeedback={false}
      />
    );

    const input = screen.getByPlaceholderText("Enter your correction...");
    const submitButton = screen.getByText("Submit Answer");

    fireEvent.change(input, { target: { value: "playing football" } });
    fireEvent.click(submitButton);

    expect(mockOnAnswer).toHaveBeenCalledWith("playing football");
  });
});
```
